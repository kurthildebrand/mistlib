/************************************************************************************************//**
 * @file		test_ipv6.c
 *
 * @copyright	Copyright 2022 Kurt Hildebrand.
 * @license		Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 * 				file except in compliance with the License. You may obtain a copy of the License at
 *
 * 				http://www.apache.org/licenses/LICENSE-2.0
 *
 * 				Unless required by applicable law or agreed to in writing, software distributed under
 * 				the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * 				ANY KIND, either express or implied. See the License for the specific language
 * 				governing permissions and limitations under the License.
 *
 ***************************************************************************************************/
#include <stdio.h>
#include <stdlib.h>

#include "test_ipv6.h"

#include "ipv6.h"
#include "tharness.h"


/* Private Variables ----------------------------------------------------------------------------- */
uint8_t ipv6_packet_data[128];
IPPacket packet;
IPAddress src = { .data =
	{0x00, 0x11, 0x22, 0x33,
	 0x44, 0x55, 0x66, 0x77,
	 0x88, 0x99, 0xAA, 0xBB,
	 0xCC, 0xDD, 0xEE, 0xFF } };

IPAddress dest = { .data = {
	0xFF, 0xEE, 0xDD, 0xCC,
	0xBB, 0xAA, 0x99, 0x88,
	0x77, 0x66, 0x55, 0x44,
	0x33, 0x22, 0x11, 0x00 }};

uint8_t ipv6_data1[]  = { 0x11, 0x11, 0x11 };
uint8_t ipv6_data2[]  = { 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22 };
uint8_t ipv6_data3[]  = { 0x33, 0x33, 0x33, 0x33, 0x33 };
uint8_t ipv6_data4[]  = { 0x44, 0x44 };
uint8_t ipv6_data5[]  = { 0x55, 0x55, 0x55, 0x55, 0x55, 0x55};
uint8_t ipv6_data6[]  = { 0x66, 0x66, 0x66, 0x66 };
uint8_t ipv6_data7[]  = { 0x77, 0x77, 0x77, 0x77 };
uint8_t ipv6_data8[]  = { 0x88, 0x88, 0x88, 0x88, 0x88 };
uint8_t ipv6_data9[]  = { 0x99, 0x99 };
uint8_t ipv6_data10[] = { 0xAA, 0xAA, 0xAA };


TEST(test_ipv6_checksum)
{
	uint16_t sum    = 0;
	uint8_t  data[] = { 0x00, 0x01, 0xF2, 0x03, 0xF4, 0xF5, 0xF6, 0xF7, };
	sum = ipv6_checksum(data, sizeof(data), sum);

	EXPECT(sum == 0xDDF2);
}


TEST(test_ipv6_init)
{
	ipv6_init (&packet, ipv6_packet_data, 0, sizeof(ipv6_packet_data));
	ipv6_clear(&packet);
	EXPECT(ipv6_version(&packet) == 6);
}


TEST(test_ipv6_set)
{
	IPAddress* ptr;

	EXPECT(ipv6_set_traffic_class(&packet, 5));
	EXPECT(ipv6_set_flow_label(&packet, 0x12345));
	EXPECT(ipv6_set_hop_limit(&packet, 12));
	EXPECT(ipv6_set_src(&packet, &src));
	EXPECT(ipv6_set_dest(&packet, &dest));

	EXPECT(ipv6_traffic_class(&packet) == 5);
	EXPECT(ipv6_flow_label(&packet) == 0x12345);
	EXPECT(ipv6_hop_limit(&packet) == 12);

	ptr = ipv6_src(&packet);
	EXPECT(ptr != 0);
	EXPECT(memcmp(&src, ptr, sizeof(IPAddress)) == 0);

	ptr = ipv6_dest(&packet);
	EXPECT(ptr != 0);
	EXPECT(memcmp(&dest, ptr, sizeof(IPAddress)) == 0);

	uint8_t expected[] = {
		0x60,0x51,0x23,0x45,0x00,0x00,0x3b,0x0c,
		0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,
		0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff,
		0xff,0xee,0xdd,0xcc,0xbb,0xaa,0x99,0x88,
		0x77,0x66,0x55,0x44,0x33,0x22,0x11,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	};

	EXPECT(memcmp(expected, ipv6_packet_data, sizeof(ipv6_packet_data)) == 0);
}


TEST(test_ipv6_ext_hdr)
{
	unsigned i;

	uint8_t expected[] = {
		IPV6_DEST_OPTS_HEADER,
//		IPV6_HBH,
		IPV6_ROUTING,
		IPV6_MOBILITY,
		IPV6_UDP,
	};

	IPExthdr header;
	header = ipv6_eh_first(&packet);
	// EXPECT(ipv6_insert_exthdr(&header, IPV6_HBH, 0, 0));
	// IPExthdr_next(&header);

	EXPECT(ipv6_eh_append(&header, IPV6_ROUTING, ipv6_data3, sizeof(ipv6_data3)));

	Buffer* buffer = ipv6_eh_reset_buffer(&header);
	buffer_push_mem(buffer, ipv6_data4, sizeof(ipv6_data4));
	ipv6_eh_finalize(&header);
	// EXPECT(ipv6_eh_push(&header, ipv6_data4, sizeof(ipv6_data4)));

	uint8_t expected1[] = {
		0x60,0x51,0x23,0x45,0x00,0x00,0x2b,0x0c,
		0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,
		0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff,
		0xff,0xee,0xdd,0xcc,0xbb,0xaa,0x99,0x88,
		0x77,0x66,0x55,0x44,0x33,0x22,0x11,0x00,
		0x3b,0x01,0x33,0x33,0x33,0x33,0x33,0x44,
		0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	};

	EXPECT(memcmp(expected1, ipv6_packet_data, sizeof(ipv6_packet_data)) == 0);

	EXPECT(ipv6_eh_append(&header, IPV6_MOBILITY, ipv6_data5, sizeof(ipv6_data5)));
	ipv6_eh_finalize(&header);

	uint8_t expected2[] = {
		0x60,0x51,0x23,0x45,0x00,0x00,0x2b,0x0c,
		0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,
		0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff,
		0xff,0xee,0xdd,0xcc,0xbb,0xaa,0x99,0x88,
		0x77,0x66,0x55,0x44,0x33,0x22,0x11,0x00,
		0x87,0x01,0x33,0x33,0x33,0x33,0x33,0x44,
		0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x3b,0x00,0x55,0x55,0x55,0x55,0x55,0x55,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	};

	EXPECT(memcmp(expected2, ipv6_packet_data, sizeof(ipv6_packet_data)) == 0);

	EXPECT(ipv6_eh_append(&header, IPV6_UDP, ipv6_data6, sizeof(ipv6_data6)));
	ipv6_eh_finalize(&header);

	uint8_t expected3[] = {
		0x60,0x51,0x23,0x45,0x00,0x00,0x2b,0x0c,
		0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,
		0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff,
		0xff,0xee,0xdd,0xcc,0xbb,0xaa,0x99,0x88,
		0x77,0x66,0x55,0x44,0x33,0x22,0x11,0x00,
		0x87,0x01,0x33,0x33,0x33,0x33,0x33,0x44,
		0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x11,0x00,0x55,0x55,0x55,0x55,0x55,0x55,
		0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	};

	EXPECT(memcmp(expected3, ipv6_packet_data, sizeof(ipv6_packet_data)) == 0);

	// for(i = 0; i < sizeof(IPPacket_data); i++)
	// {
	// 	PRINT("%d ", i);

	// 	if(expected3[i] != IPPacket_data[i])
	// 	{
	// 		PRINT("> ");
	// 	}
	// 	else
	// 	{
	// 		PRINT("  ");
	// 	}

	// 	PRINT("%02X %02X\n", expected3[i], IPPacket_data[i]);
	// }

	/* IPv6_HBH, IPv6_ROUTING, IPv6_MOBILITY, IPv6_UDP */

	header = ipv6_eh_first(&packet);
	EXPECT(ipv6_eh_prepend(&header, IPV6_DEST_OPTS_HEADER, ipv6_data1, sizeof(ipv6_data1)));
	ipv6_eh_finalize(&header);

	uint8_t expected4[] = {
		0x60,0x51,0x23,0x45,0x00,0x00,0x3c,0x0c,
		0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,
		0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff,
		0xff,0xee,0xdd,0xcc,0xbb,0xaa,0x99,0x88,
		0x77,0x66,0x55,0x44,0x33,0x22,0x11,0x00,
		0x2b,0x00,0x11,0x11,0x11,0x00,0x00,0x00,
		0x87,0x01,0x33,0x33,0x33,0x33,0x33,0x44,
		0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x11,0x00,0x55,0x55,0x55,0x55,0x55,0x55,
		0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	};

	EXPECT(memcmp(expected4, ipv6_packet_data, sizeof(ipv6_packet_data)) == 0);

	for(i = 0; i < sizeof(ipv6_packet_data); i++)
	{
		PRINT("%d ", i);

		if(expected4[i] != ipv6_packet_data[i])
		{
			PRINT("> ");
		}
		else
		{
			PRINT("  ");
		}

		PRINT("%02X %02X\n", expected4[i], ipv6_packet_data[i]);
	}

	EXPECT(!ipv6_eh_append(&header, IPV6_TCP, ipv6_data2, sizeof(ipv6_data2)));
	ipv6_eh_finalize(&header);

//	EXPECT(ipv6_insert_exthdr(&header, IPV6_ROUTING, ipv6_data3, sizeof(ipv6_data3)));
//	EXPECT(IPExthdr_push(&header, ipv6_data4, sizeof(ipv6_data4)));
//	IPExthdr_next(&header);
//
//	EXPECT(ipv6_insert_exthdr(&header, IPV6_MOBILITY, ipv6_data5, sizeof(ipv6_data5)));
//	IPExthdr_next(&header);
//
//	EXPECT(ipv6_insert_exthdr(&header, IPV6_UDP, ipv6_data6, sizeof(ipv6_data6)));
//	IPExthdr_next(&header);
//
//	/* IPv6_HBH, IPv6_ROUTING, IPv6_MOBILITY, IPv6_UDP */
//
//	header = IPExthdr_first(&packet);
//	EXPECT(ipv6_insert_exthdr(&header, IPV6_DEST_OPTS_HEADER, ipv6_data1, sizeof(ipv6_data1)));
//	IPExthdr_next(&header);
//
//	EXPECT(!ipv6_insert_exthdr(&header, IPV6_TCP, ipv6_data2, sizeof(ipv6_data2)));
//	IPExthdr_next(&header);

	/* DEST_OPTS_HEADER, IPv6_TCP, IPv6_HBH, IPv6_ROUTING, IPv6_MOBILITY, IPv6_UDP */

//	IPExthdr header;
//	header = IPExthdr_first(&packet);
//	EXPECT(ipv6_append_exthdr(&header, IPV6_HBH, 0, 0));
//	EXPECT(ipv6_append_exthdr(&header, IPV6_ROUTING, ipv6_data3, sizeof(ipv6_data3)));
//	EXPECT(IPExthdr_push(&header, ipv6_data4, sizeof(ipv6_data4)));
//	EXPECT(ipv6_append_exthdr(&header, IPV6_MOBILITY, ipv6_data5, sizeof(ipv6_data5)));
//	EXPECT(ipv6_append_exthdr(&header, IPV6_UDP, ipv6_data6, sizeof(ipv6_data6)));
//
//	/* IPv6_HBH, IPv6_ROUTING, IPv6_MOBILITY, IPv6_UDP */
//
//	header = IPExthdr_first(&packet);
//	EXPECT(ipv6_prepend_exthdr(&header, IPV6_DEST_OPTS_HEADER, ipv6_data1, sizeof(ipv6_data1)));
//	EXPECT(!ipv6_append_exthdr(&header, IPV6_TCP, ipv6_data2, sizeof(ipv6_data2)));
//
//	/* DEST_OPTS_HEADER, IPv6_TCP, IPv6_HBH, IPv6_ROUTING, IPv6_MOBILITY, IPv6_UDP */

	i = 0;
	header = ipv6_eh_first(&packet);
	while(ipv6_eh_is_valid(&header))
	{
		EXPECT(ipv6_eh_type(&header) == expected[i]);
		PRINT("%d\n", ipv6_eh_type(&header));
		ipv6_eh_next(&header);
		i++;
	}
}


TEST(test_ipv6_option)
{
	unsigned i;

	IPExthdr header;
	IPOption option;

	header = ipv6_eh_first(&packet);
	EXPECT(ipv6_eh_prepend(&header, IPV6_HBH, 0, 0));

	option = ipv6_opt_first(&header);
	EXPECT(ipv6_opt_append(&option, 0xEE, ipv6_data7, sizeof(ipv6_data7), 4, 2));
	ipv6_opt_finalize(&option);

	EXPECT(ipv6_opt_append(&option, 0xFF, ipv6_data8, sizeof(ipv6_data8), 4, 2));
	ipv6_opt_finalize(&option);

	EXPECT(ipv6_opt_append(&option, 0xDD, ipv6_data9, sizeof(ipv6_data9), 4, 2));

	Buffer* buffer = ipv6_opt_reset_buffer(&option);
	buffer_push_mem(buffer, ipv6_data10, sizeof(ipv6_data10));
	ipv6_opt_finalize(&option);
	// EXPECT(ipv6_opt_push(&option, ipv6_data10, sizeof(ipv6_data10)));

	ipv6_eh_finalize(&header);

	uint8_t expected[] = {
		0x60,0x51,0x23,0x45,0x00,0x00,0x00,0x0c,
		0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,
		0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff,
		0xff,0xee,0xdd,0xcc,0xbb,0xaa,0x99,0x88,
		0x77,0x66,0x55,0x44,0x33,0x22,0x11,0x00,

		0x3c,0x03,0xee,0x04,0x77,0x77,0x77,0x77,
		0x01,0x00,0xff,0x05,0x88,0x88,0x88,0x88,
		0x88,0x00,0xdd,0x05,0x99,0x99,0xaa,0xaa,
		0xaa,0x01,0x05,0x00,0x00,0x00,0x00,0x00,

		0x2b,0x00,0x11,0x11,0x11,0x00,0x00,0x00,

		0x87,0x01,0x33,0x33,0x33,0x33,0x33,0x44,
		0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

		0x11,0x00,0x55,0x55,0x55,0x55,0x55,0x55,

		0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	};

	EXPECT(memcmp(expected, ipv6_packet_data, sizeof(ipv6_packet_data)) == 0);

	for(i = 0; i < sizeof(ipv6_packet_data); i++)
	{
		PRINT("%d ", i);

		if(expected[i] != ipv6_packet_data[i])
		{
			PRINT("> ");
		}
		else
		{
			PRINT("  ");
		}

		PRINT("%02X %02X\n", expected[i], ipv6_packet_data[i]);
	}

	/* Do not recommend finding a header then appending options to it. Best to append options
	 * immediately after appending the header to avoid excessive padding. */
//	EXPECT(ipv6_find_header(&packet, &header, IPV6_HBH));

	/* TODO: there is a bug with appending options when headers found by ipv6_find_header.
	 * ipv6_find_header sets the header range to 8 byte boundaries even if the content does not fill
	 * the header completely. */
	// option = ipv6_option_first(&header);
	// EXPECT(ipv6_append_option(&option, 0xEE, ipv6_data7, sizeof(ipv6_data7), 4));
	// EXPECT(ipv6_append_option(&option, 0xFF, ipv6_data8, sizeof(ipv6_data8), 4));
	// EXPECT(ipv6_append_option(&option, 0xDD, ipv6_data9, sizeof(ipv6_data9), 4));
	// EXPECT(ipv6_option_push(&option, ipv6_data10, sizeof(ipv6_data10)));

	option = ipv6_opt_first(&header);
	while(ipv6_opt_is_valid(&option))
	{
		PRINT("%X\n", ipv6_opt_type(&option));
		ipv6_opt_next(&option);
	}
}


void test_ipv6()
{
	IPExthdr header;
	IPOption option;

	tharness_run(test_ipv6_checksum);
	tharness_run(test_ipv6_init);
	tharness_run(test_ipv6_set);
	tharness_run(test_ipv6_ext_hdr);
	tharness_run(test_ipv6_option);

//	ipv6_finalize(&packet);

	header = ipv6_eh_first(&packet);

	while(ipv6_eh_is_valid(&header))
	{
		PRINT("%d\n", ipv6_eh_type(&header));

		if(ipv6_eh_type(&header) == IPV6_HBH)
		{
			option = ipv6_opt_first(&header);

			while(ipv6_opt_is_valid(&option))
			{
				PRINT("\t%X\n", ipv6_opt_type(&option));
				ipv6_opt_next(&option);
			}
		}

		ipv6_eh_next(&header);
	}
}


/******************************************* END OF FILE *******************************************/
